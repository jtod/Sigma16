; Logic: Test logic operations
; Instructions logicw, logicb, and their pseudoinstructions
; Sigma16: https://jtod.github.io/home/Sigma16  John O'Donnell, 2025

;---------------------------------------------------------------------
; Instruction format:
;   First word    op d  a  b    (ab is 8-bit secondary opcode)
;   Second word   e  f  g  h

; Bit indexing: Rd.i is bit at index i in Rd

; Assembly language notation: an operand which is one of d, e, f, g, h
; is represented as a 4-bit number in the corresponding field in the
; instruction format.  Thus if the an operand has the form e,Rf, then
; an instruction with operand 3,R4 would place 3 in field e and 4 in
; f.

; Machine language notation: a digit 0-9 and an uppercase letter from
; A to F indicates a constant hex digit value.  A lower case letter
; (op, d, a, b, e, f, g, h) is a variable giving the value of the
; corresponding field in the instruction format.  The value is
; specified by the assembly language statement.

; Symbolic names for common logic function codes

invx equ     12
and  equ     1
or   equ     7
xor  equ     6
nand equ     14
nor  equ     8
xnor equ     9

;---------------------------------------------------------------------
; logicf - bitwise logic on fields

;    logicf  Rd,Re,f,g,h
;      effect:  Rd.f:g := map2 h (Rd.f:g, Re.f:g)
;      Rd = first operand register and destination register
;      Re = second operand register
;      f = index of rightmost bit in field (in both registers))
;      g = index of leftmost bit in field (in both registers)
;      h = logic function
;      format: EXP
;      machine language: Ed00 efgh (op=$E, ab=$00)
     logicf  R3,R9,5,8,xor   ; e300 9586

; Testing logicf

     lea     R1,$3333[R0]   ; R1 := 3333
     lea     R2,$5555[R0]   ; R2 := 5555
     logicf  R1,R2,0,3,and  ; R1 := 3331
     logicf  R1,R2,4,7,or   ; R1 := 3371
     logicf  R1,R2,8,11,xor ; R1 := 3671

; logicf pseudoinstructions
;   Pseudoinstructions that end with w operate on entire word
;   Those that end with f operate on a field

;    invw    Rd            ; logicf Rd,Re,0,15,invx
;    andw    Rd,Re         ; logicf Rd,Re,0,15,and
;    orw     Rd,Re         ; logicf Rd,Re,0,15,or
;    xorw    Rd,Re         ; logicf Rd,Re,0,15,xor

;    invf    Rd,f,g        ; logicf Rd,R0,f,g,invx
;    andf    Rd,Re,f,g     ; logicf Rd,Re,f,g,and
;    orf     Rd,Re,f,g     ; logicf Rd,Re,f,g,or
;    xorf    Rd,Re,f,g     ; logicf Rd,Re,f,g,xor

; Testing logicf pseudoinstructions

     lea   R3,$f0f0[R0]   ; R3 := f0f0
     invw  R3             ; R3 := 0f0f

     lea   R1,$f0f0[R0]   ; R1 := f0f0
     lea   R2,$00ff[R0]   ; R2 := 00ff
     andw  R1,R2          ; R1 := 00f0

     lea   R1,$f0f0[R0]   ; R1 := f0f0
     lea   R2,$00ff[R0]   ; R2 := 00ff
     orw   R1,R2          ; R1 := f0ff
     xorw  R1,R2          ; R1 := f000

     lea     R1,$00ff[R0]   ; R1 := 00ff
     lea     R2,$0f0f[R0]   ; R2 := 0f0f

     invw    R2             ; R2 := f0f0
     invw    R2             ; R2 := 0f0f
     andw    R1,R2          ; R1 := 000f
     lea     R1,$00ff[R0]   ; R1 := 00ff
     orw     R1,R2          ; R1 := 0fff
     lea     R1,$00ff[R0]   ; R1 := 00ff
     xorw    R1,R2          ; R1 := 0ff0

     lea     R1,$006f[R0]
     invf    R1,4,7         ; R1 := 009f
     lea     R1,$005f[R0]
     andf    R1,R2,4,11      ; R1 := 
     lea     R1,$00ff[R0]
     orf     R1,R2,4,7
     lea     R1,$00ff[R0]
     xorf    R1,R2,4,7

;---------------------------------------------------------------------; logicb - bit logic, overwrites the first operand

;    logicb  Rd,Re,f,g,h
;      Rd.f := h (Rd.f, Re.g)
;      EXP op=$e ab=$01
     logicb  R7,R9,3,5,6    ; e701 9356

; Test assembly of EXP/aRRkkk
     logicb  R7,R9,3,5,6    ; e701 9356

; Testing logicb

   lea    R2,$0f00[R0]   ; R2 := 0f00 (R2.9 := 1)
   lea    R7,$2000[R0]   ; R7 := 2000 (R7.13 := 1)
   logicb R2,R7,9,13,xor ; R2 := 0d00 (R2.9 := R2.9 xor R7.13 = 0)

     lea     R1,$00ff[R0]
     lea     R2,$00f0[R0]
     logicb  R1,R2,8,4,or   ; 01ff
     logicb  R1,R2,7,4,and  ; 01ff
     logicb  R1,R2,6,3,and  ; 01bf

     lea     R2,$0200[R0]   ; R2.9 := 1
     lea     R7,$0000[R0]   ; R7.13 := 0
     logicb  R2,R7,9,13,xor ; e214 97d6. R2 := 0200

     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     logicb  R1,R2,7,3,and  ; R1.7 := 0 and 0 = 0, R1 := 0030
     logicb  R1,R2,6,2,and  ; R1.6 := 0 and 1 = 0, R1 := 0030
     logicb  R1,R2,5,1,and  ; R1.5 := 1 and 0 = 0, R1 := 0010
     logicb  R1,R2,4,0,and  ; R1.4 := 1 and 1 = 1, R1 := 0010

     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     logicb  R1,R2,7,3,or   ; R1.7 := 0 or 0 = 0, R1 := 0030
     logicb  R1,R2,6,2,or   ; R1.6 := 0 or 1 = 1, R1 := 0070
     logicb  R1,R2,5,1,or   ; R1.5 := 1 or 0 = 1, R1 := 0070
     logicb  R1,R2,4,0,or   ; R1.4 := 1 or 1 = 1, R1 := 0070

     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     logicb  R1,R2,7,3,xor  ; R1.7 := 0 xor 0 = 0, R1 := 0030
     logicb  R1,R2,6,2,xor  ; R1.6 := 0 xor 1 = 1, R1 := 0070
     logicb  R1,R2,5,1,xor  ; R1.5 := 1 xor 0 = 1, R1 := 0070
     logicb  R1,R2,4,0,xor  ; R1.4 := 1 xor 1 = 0, R1 := 0060

;     logicb  R1,3,0,0,inv   ; R1 := 176a  R1.3 = 1
;     logicb  R1,2,1,0,inv   ; R1 := 176a  R1.2 = 0

; logicb pseudoinstructions

;    invb    Rd,e           ; logicb Rd,e,R0,0,7
;    andb    Rd,e,Rf,g      ; logicb Rd,e,Rf,g,and
;    orb     Rd,e,Rf,g      ; logicb Rd,e,Rf,g,or
;    xorb    Rd,e,Rf,g      ; logicb Rd,e,Rf,g,xor

; Test assembly of EXP/aRk pseudo
     invb    R3,5           ; e301 050c (logicb R3,R0,6,0,12)
     setb    R4,7           ; e401 070f (logicb R4,R0,7,0,15)
     clearb  R5,8           ; e501 0800 ( logicb R5,R0,8,0,0)

     add     R4,R0,R0       ; R4 := 0000
     setb    R4,7           ; R4 := 0080 (R4.7 := 1)

     lea     R4,$ffff[R0]   ; R4 := ffff
     clearb  R4,7           ; R4 := ff7f (R4.7 := 0)

     add     R4,R0,R0       ; R4 := 0000
     lea     R12,$0020[R0]  : R12 = 0020
     copyb   R4,R12,7,5     ; R4 := 0080 (R4.7 := R12.5)

     add     R4,R0,R0       ; R4 := 0
     copybi  R4,R0,6,5      ; R4 := 0040 (R4.6 := inv R0.5)

; Testing logicb pseudoinstructions

     lea     R1,$0050[R0]   ; R1 := 0050
 ;    invb    R1,4           ; R1 := 0040
     
     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     andb    R1,R2,7,3      ; R1.7 := 0 and 0 = 0, R1 := 0030
     andb    R1,R2,6,2      ; R1.6 := 0 and 1 = 0, R1 := 0030
     andb    R1,R2,5,1      ; R1.5 := 1 and 0 = 0, R1 := 0010
     andb    R1,R2,4,0      ; R1.4 := 1 and 1 = 1, R1 := 0010

     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     orb     R1,R2,7,3      ; R1.7 := 0 or 0 = 0, R1 := 0030
     orb     R1,R2,6,2      ; R1.6 := 0 or 1 = 1, R1 := 0070
     orb     R1,R2,5,1      ; R1.5 := 1 or 0 = 1, R1 := 0070
     orb     R1,R2,4,0      ; R1.4 := 1 or 1 = 1, R1 := 0070

     lea     R1,$0030[R0]   ; R1 := 0030
     lea     R2,$0005[R0]   ; R2 := 0005
     xorb    R1,R2,7,3      ; R1.7 := 0 xor 0 = 0, R1 := 0030
     xorb    R1,R2,6,2      ; R1.6 := 0 xor 1 = 1, R1 := 0070
     xorb    R1,R2,5,1      ; R1.5 := 1 xor 0 = 1, R1 := 0070
     xorb    R1,R2,4,0      ; R1.4 := 1 xor 1 = 0, R1 := 0060

     trap    R0,R0,R0

