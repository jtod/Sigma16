<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="John T. O'Donnell" />
  <title>Sigma16 User's Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Sigma16 User's Guide</h1>
<h2 class="author">John T. O'Donnell</h2>
<h3 class="date">version:	  1.4.4 (build 23 Feb 2016)</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#running-an-example-program">Running an example program</a></li>
</ul></li>
<li><a href="#instruction-set-architecture">Instruction Set Architecture</a><ul>
<li><a href="#data-representation">Data representation</a></li>
<li><a href="#registers">Registers</a></li>
<li><a href="#condition-codes">Condition codes</a></li>
<li><a href="#processor-status-flags">Processor status flags</a></li>
<li><a href="#memory">Memory</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#instructions">Instructions</a></li>
</ul></li>
<li><a href="#assembly-language">Assembly Language</a><ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#assembly-instruction-fields">Assembly instruction fields</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#assembly-language-statements">Assembly language statements</a></li>
<li><a href="#object-language-statements">Object language statements</a></li>
<li><a href="#assembly-listing">Assembly listing</a></li>
</ul></li>
<li><a href="#linker">Linker</a></li>
<li><a href="#programming-the-sigma16-architecture">Programming the Sigma16 architecture</a></li>
<li><a href="#using-the-graphical-user-interface">Using the graphical user interface</a></li>
<li><a href="#about-the-software">About the software</a><ul>
<li><a href="#changes-underway">Changes underway</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#using-a-pre-compiled-directory">Using a pre-compiled directory</a></li>
</ul></li>
</ul>
</div>
<h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p>Sigma16 is a 16-bit computer architecture, with a regular and simple instruction set. This application provides a complete environment for developing and experimenting with Sigma16 at the instruction set level. It contains an assembler and emulator, along with in interactive design environment.</p>
<h2 id="getting-started"><a href="#getting-started">Getting started</a></h2>
<p>This reference manual is organised by topic, with chapters on the architecture, the assembly language, and the emulator. However, it's a good idea to get an overview of how the whole system works, and to be able to write and run simple programs, before delving into all the details. For a quick start, begin with the following sections, which are organized as standalone tutorials:</p>
<ul>
<li><p><a href="#tutorial-running-an-example-program">Tutorial: Running an example program</a> shows how to load an example program, assemble it, and run it.</p></li>
<li><p><a href="#tutorial-introduction-to-programming">Tutorial: Introduction to programming</a> explains the basic programming techniques you need for small problems.</p></li>
<li><p><a href="#summary-of-the-instruction-set">Summary of the instruction set</a> gives a short synopsis of each instruction, which you may want to refer to frequently while programming.</p></li>
</ul>
<p>After working through the tutorials, it's helpful to go back to the beginning and read through the entire document.</p>
<h2 id="running-an-example-program"><a href="#running-an-example-program">Running an example program</a></h2>
<p>A good way to get started is to go through the entire process of entering a simple program, assembling it, and running it. This section shows you how. For now, we focus just on how to use the software tools; an explanation of the Sigma16 architecture comes later.</p>
<p><strong>Launch the application.</strong> A window will appear with several panes, and the Welcome* pane will be visible.</p>
<p><strong>View the user manual.</strong> Click Menu: Help: View user manual in web browser. You can also point your web browser to the file; this is normally in HydraGUI-1.2.3-installation/doc/html/index.html, where the 1.2.3 will actually be the version number. The help is available in two forms: an html pages you can read in a browser, and a pdf file suitable for printing.</p>
<h3 id="editor-loading-a-program"><a href="#editor-loading-a-program">Editor: loading a program</a></h3>
<p><strong>View the editor.</strong> Click on the tab labelled Editor. You can load an assembly language program into this pane, edit it, and save it.</p>
<p><strong>Load an example program.</strong> Click <strong>Menu File: Open</strong>. The <em>Open File...</em> dialogue box will pop up. You can use this to navigate to programs you have written, but there is also a set of examples that come with Hydra. In the <em>Places</em> pane, click <em>Sigma16</em> and a set of example programs will appear. Click <em>Add.asm.txt</em> and then click <em>Open</em> (or you can double click the file name). The dialogue box disappears, and the contents of the file will be visible in the editor pane. You can edit the program, but don't do that now because that might prevent the example from working!</p>
<h3 id="assembler-translating-assembly-to-machine-language"><a href="#assembler-translating-assembly-to-machine-language">Assembler: translating assembly to machine language</a></h3>
<p><strong>Assemble the program.</strong> Click the Assembler tab. As you follow the normal workflow in developing a program, you'll follow the various panes from left to right. Initially the Assembler page is empty. Click <em>Assemble</em>, and the system will read in the current program (the text on the <em>Source Code</em> page) and translate it into machine language. The left side of each line in the output shows the machine language (the object code), while the right side shows the original assembly language text (the source code).</p>
<p>This example program doesn't produce any error messages, so we can move on. The next part of the tutorial will look at how to handle errors.</p>
<h3 id="linker-preparing-for-execution"><a href="#linker-preparing-for-execution">Linker: preparing for execution</a></h3>
<p>(The linker is not yet available.)</p>
<p>The Linker pane shows the object module, which consists of the machine language code that you've already seen in the assembler listing. If your program contains just one module, then its machine language module is already executable. In this case you don't need to do anything on the Linker page, so you can just skip past it. However, if the program contains several modules that need to be linked together, the Linker pane is the place to do it.</p>
<h3 id="processor-running-the-program"><a href="#processor-running-the-program">Processor: running the program</a></h3>
<p><strong>Click Processor tab.</strong> The Processor page shows the state of the processor as it runs your program, and the assembly listing is shown below, to help you follow the execution of the program.</p>
<p><strong>Load</strong>. The current object program (which appears in the Linker page) will be copied into the memory. There are two independent views into the memory; this is convenient for looking at the machine language code in one view and the data in the other view. (Despite the two views, there is just one memory!)</p>
<p>When a memory word has been modified, it is temporarily highlighted in red. The machine language code from the Add object module has been stored into the first dozen or so words of memory, and they are marked in red.</p>
<p>When you launched the program, the processor status changed to <em>Running</em>. This means that the virtual Sigma16 processor is running, but the emulator is actually stopped and awaiting your command.</p>
<p>At this point the pc register contains 0, meaning that the next instruction to be executed is the one in memory location 0. The ir and other registers also contain 0, but that is just the initial value.</p>
<p><strong>Step</strong>. The processor will execute one instruction and stop, showing the state of the machine after the instruction finishes. Click Step several times to see the effect of executing several instructions.</p>
<p><strong>Run</strong>. This causes the processor to execute instructions repeatedly, so you don't have to click Step each time. The program will continue running until it terminates by executing the instruction <em>trap R0,R0,R0</em>. When this happens, the status changes from Running to Halted. There is a speed slider that allows you to run the program faster or slower, which makes it easier to see what is happening.</p>
<h1 id="instruction-set-architecture"><a href="#instruction-set-architecture">Instruction Set Architecture</a></h1>
<p>An <em>instruction set architecture</em> is a precise specification of all aspects of a machine that are visible to a programmer. It includes a description of the registers, memory, data representations, and all the instructions, but does not include components of the implementation that are not visible to a machine language programmer.</p>
<h2 id="data-representation"><a href="#data-representation">Data representation</a></h2>
<p>Sigma16 is a 16-bit architecture, and every data value is a 16-bit word. Integers are represented in 16-bit two's complement notation. The bits of a word are numbered from left to right, starting with 0. Thus the leftmost (most significant) bit of a word is bit 0, and the rightmost (least significant) is bit 15.</p>
<h2 id="registers"><a href="#registers">Registers</a></h2>
<p>The <strong>register file</strong> is a set of 16 general registers that hold a 16 bit word. A register is referenced by a 4-bit binary number. In assembly language, we use the notations R0, R1, R2, ..., R9, R10, R11, R12, R13, R14, R15 to refer to the registers.</p>
<p>One of the registers, R0, has a special property: it always contains the constant 0. It is legal to perform an instruction that attempts to load some other value into R0, but the register will still contain 0 after executing such an instruction. Such an instruction will simply have no lasting effect.</p>
<p>Apart from R0, all the instructions behave exactly the same way, at least as far as the hardware is concerned.</p>
<p>There are some programming conventions that use certain registers for special purposes. The hardware does not enforce, or even know about, these conventions, and you do not have to follow the conventions in programming. However, it is necessary to obey the conventions in order to use the standard software libraries in your program. See the section on Programming for a discussion of these standard usage conventions.</p>
<p>There are several <strong>program control registers</strong> that enable the processor to keep track of the state of the running program. These registers are rarely used directly by the machine language program, but they are essential for keeping track of the execution of the program, and some instructions use them directly.</p>
<ul>
<li><p>ir -- instruction register (16-bit word)</p></li>
<li><p>pc -- program counter (16-bit word)</p></li>
<li><p>rem -- word extension register (16-bit word)</p></li>
<li><p>adr -- address register (16-bit word)</p></li>
<li><p>dat -- data register (16-bit word)</p></li>
</ul>
<h2 id="condition-codes"><a href="#condition-codes">Condition codes</a></h2>
<p>Several instructions produce status information: the result of a comparison, whether there was an overflow, etc. This information is automatically loaded into R15, which is the condition code register. The description of each instruction states whether R15 is modified, and what goes into it.</p>
<p>The bits in R15 are indexed from bit 0 (the least significant, or rightmost bit) to bit 15 (the most significant, or leftmost). The condition code bits that have specific meanings are called <em>flags</em>. The flags are defined to make the condition code easier to read in hex: comparison flags are in the rightmost hex digit, and the carry and overflow flags are in the hex digit to the left.</p>
<hr />
<table>
<caption>Condition code flags</caption>
<thead>
<tr class="header">
<th align="center">Bit</th>
<th align="center">Flag</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center"><strong>gt</strong></td>
<td align="left">Result of <em>cmp</em> is &gt;, or result of arith &gt; 0</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center"><strong>eq</strong></td>
<td align="left">Result of <em>cmp</em> is =, or arith result = 0</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center"><strong>lt</strong></td>
<td align="left">Result of <em>cmp</em> is &lt;, or arith result &lt; 0</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="center"><strong>c</strong></td>
<td align="left">Carry propagation</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="center"><strong>ov</strong></td>
<td align="left">Overflow</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="processor-status-flags"><a href="#processor-status-flags">Processor status flags</a></h2>
<p>The processor can be executing in several modes, which are determined by the <strong>system control registers</strong>.</p>
<ul>
<li><p>ie -- interrupts enabled (1-bit flag)</p></li>
<li><p>sys -- system state (1-bit flag)</p></li>
</ul>
<h2 id="memory"><a href="#memory">Memory</a></h2>
<p>The memory is a hardware array of words that are accessed by address. A memory address is 16 bits wide, and there is one memory location corresponding to each address, so there are 2^16 = 64k memory locations. Each memory location is a 16-bit word.</p>
<h2 id="exceptions"><a href="#exceptions">Exceptions</a></h2>
<table>
<thead>
<tr class="header">
<th align="center">Location</th>
<th align="left">Exception</th>
<th align="left">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="left">Trap</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="left">Overflow</td>
<td align="left">Trap</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="left">Div0</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="left">SegFault</td>
<td align="left">Trap</td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="left">Privilege</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="left">Timer</td>
<td align="left">Interrupt</td>
</tr>
<tr class="odd">
<td align="center">6</td>
<td align="left">Input</td>
<td align="left">Interrupt</td>
</tr>
<tr class="even">
<td align="center">7</td>
<td align="left">Output</td>
<td align="left">Interrupt</td>
</tr>
</tbody>
</table>
<h2 id="instructions"><a href="#instructions">Instructions</a></h2>
<p>Sigma16 is a load/store style architecture; that is, it does not combine memory accesses with arithmetic. All calculations are carried out in the register file, and explicit load and store instructions must be used to copy data between the memory and the register file.</p>
<p>There are three instruction formats:</p>
<ul>
<li><p>RRR -- (1 word) Instructions that perform operations on data in registers, but not referring to memory.</p></li>
<li><p>RX -- (2 words) Instructions that specify a memory location, as well as a register operand.</p></li>
<li><p>EXP -- (2 words) Expanded instructions, for instructions that cannot be encoded as RRR or RX.</p></li>
</ul>
<p>The first word of an instruction contains four 4-bit fields, named op (bits 0-3), d (bits 4-7), sa (bits 8-11), and sb (bits 12-15).</p>
<p>Each instruction has a 4-bit field called the opcode (op for short). This gives 16 values of the opcode: 14 of them denote the 14 RRR instructions, while two of these values indicate that the instruction is either RX or XX format, and there is then a secondary opcode in the sb field</p>
<p>Expanding opcodes</p>
<pre><code>        e     XX format
        f     RX format</code></pre>
<h3 id="rrr-format"><a href="#rrr-format">RRR format</a></h3>
<p>An RRR instruction contains an operation code (op), and specifies three operands registers using the d, sa, and sb fields. It is represented as one word, which is divided into four fields:</p>
<div class="figure">
<img src="figures/RRRformat.png" alt="RRR instruction format" /><p class="caption"><strong>RRR instruction format</strong></p>
</div>
<ul>
<li>op (4 bits, starting from bit 0) Operation code</li>
<li>d (4 bits, starting from bit 4) Destination register</li>
<li>sa (4 bits, starting from bit 8) Source a register</li>
<li>sb (4 bits, starting from bit 12) Source b register</li>
</ul>
<p>The op field of an RRR instruction must be in the range from 0 through 13 (hex 0 through d). This allows for a total of 14 distinct RRR instructions. If the op field is outside this range, it indicates an &quot;expanding opcode&quot;: 14 (hex e) indicates the EXP format, and 15 (hex f) indicates the RX format.</p>
<p>A typical example of an RRR instruction is add R4,R9,R2, which adds the contenst of registers R9 and R2, and loads the result into R4. It's equivalent to R4 := R9 + R2.</p>
<p>The following table summarises the RRR instructions. Most of the instructions take two operands, which are specified in the sa and sb fields, and produce a result which is loaded into the destination register. However, a few instructions vary from this pattern. Detailed specifications of the instructions are given below the table.</p>
<h3 id="rx-format"><a href="#rx-format">RX format</a></h3>
<p>The RX instruction format is used for instructions that use a memory address, which is specified by an index register and a displacement. The name of the format describes briefly the two operands: a register (R) and an indexed memory address (X).</p>
<div class="figure">
<img src="figures/RXformat.png" alt="RX instruction format" /><p class="caption"><strong>RX instruction format</strong></p>
</div>
<p>An RX instruction contains two operands: one is a memory address, and the other is a register. Typical RX instructions are loads, stores, and jumps. The instruction consists of two consecutive words. The first has the same format as an RRR instruction, with four fields: op, d, sa, sb. The second word is a single 16-bit binary number, and is called the displacement.</p>
<p>The memory address is specified in two parts: an index register and the displacement. The index register is specified in the sa field. In assembly language, the notation used is number[reg], where the number is the value of the displacement, and the reg is the index register. Thus $20b3[R2] means the address has displacement $20b3 and the index register is R2.</p>
<p>When the machine executes an RX instruction, it begins by calculating the effective address. This is abbreviated &quot;ea&quot;, and its value is the sum of the displacement and the contents of the index register.</p>
<p>RX instructions are represented in two words, and they use an &quot;expanding opcode&quot;. That is, the op field of the first word of the instruction contains the constant f (the bits 1111) for every RX instruction, and the sb field is used to hold a secondary opcode indicating which RX instruction it is.</p>
<p>The register operand is specified in the d field. For several RX instructions, this is indeed the destination of the instruction: for example, load places data into Rd. However, a few RX instructions use the d field differently (see, for example, the conditional jump instructions).</p>
<p>The memory address is specified using the sa field and the displacement, which is the entire second word of the instruction.</p>
<h3 id="exp-format"><a href="#exp-format">EXP format</a></h3>
<p>The EXP instruction format is used for expanded instructions cannot be represented using the RRR or RX formats. It provides many unused opcodes, so it is useful for experimental instructions.</p>
<div class="figure">
<img src="figures/EXPformat.png" alt="EXP instruction format" /><p class="caption"><strong>EXP instruction format</strong></p>
</div>
<p>An EXP instruction consists of two words. The first word has a constant hex e in the op field, which indicates the EXP format. The opx1 and opx2 fields constitute an 8-bit expanded opcode. The d, sa, and sb fields in the second word are used for three register operands.</p>
<h3 id="description-of-each-instruction"><a href="#description-of-each-instruction">Description of each instruction</a></h3>
<p>load. The effective address is calculated. The word at this address is fetched from the memory, and loaded into the destination register.</p>
<p>add. The two operands are fetched from registers, added, and the sum is loaded into the destination register.</p>
<p>The following table shows the complete instruction set. The instructions are in order of increasing operation code.</p>
<p>Register file Memory</p>
<p>Control registers pc ir ad q</p>
<p>Shorthand notation ea m[ea] r[d] r[a] r[b] q#r[d] lsb q</p>
<p>Register file</p>
<h3 id="summary-of-the-instruction-set"><a href="#summary-of-the-instruction-set">Summary of the instruction set</a></h3>
<hr />
<table>
<col width="12%" />
<col width="9%" />
<col width="6%" />
<col width="9%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Mnemonic</th>
<th align="left">Format</th>
<th align="left">Op</th>
<th align="left">Notes</th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">add</td>
<td align="left">RRR</td>
<td align="left">0</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] + r[b]</td>
</tr>
<tr class="even">
<td align="left">sub</td>
<td align="left">RRR</td>
<td align="left">1</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] - r[b]</td>
</tr>
<tr class="odd">
<td align="left">mul</td>
<td align="left">RRR</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] * r[b]</td>
</tr>
<tr class="even">
<td align="left">div</td>
<td align="left">RRR</td>
<td align="left">3</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] div r[b], rem := r[a] rem r[b]</td>
</tr>
<tr class="odd">
<td align="left">cmplt</td>
<td align="left">RRR</td>
<td align="left">4</td>
<td align="left"></td>
<td align="left">r[d] := r[a] &lt; r[b]</td>
</tr>
<tr class="even">
<td align="left">cmpeq</td>
<td align="left">RRR</td>
<td align="left">5</td>
<td align="left"></td>
<td align="left">r[d] := r[a] = r[b]</td>
</tr>
<tr class="odd">
<td align="left">cmpgt</td>
<td align="left">RRR</td>
<td align="left">6</td>
<td align="left"></td>
<td align="left">r[d] := r[a] &gt; r[b]</td>
</tr>
<tr class="even">
<td align="left">inv</td>
<td align="left">RRR</td>
<td align="left">7</td>
<td align="left"></td>
<td align="left">r[d] := inv r[a]</td>
</tr>
<tr class="odd">
<td align="left">and</td>
<td align="left">RRR</td>
<td align="left">8</td>
<td align="left"></td>
<td align="left">r[d] := r[a] and r[b]</td>
</tr>
<tr class="even">
<td align="left">or</td>
<td align="left">RRR</td>
<td align="left">9</td>
<td align="left"></td>
<td align="left">r[d] := r[a] or r[b]</td>
</tr>
<tr class="odd">
<td align="left">xor</td>
<td align="left">RRR</td>
<td align="left">a</td>
<td align="left"></td>
<td align="left">r[d] := r[a] xor r[b]</td>
</tr>
<tr class="even">
<td align="left">shiftl</td>
<td align="left">RRR</td>
<td align="left">b</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] shl r[b]</td>
</tr>
<tr class="odd">
<td align="left">shiftr</td>
<td align="left">RRR</td>
<td align="left">c</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] shr r[b]</td>
</tr>
<tr class="even">
<td align="left">trap</td>
<td align="left">RRR</td>
<td align="left">d</td>
<td align="left">E</td>
<td align="left">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td align="left">lea</td>
<td align="left">RX</td>
<td align="left">f,0</td>
<td align="left"></td>
<td align="left">r[d] := ea</td>
</tr>
<tr class="even">
<td align="left">load</td>
<td align="left">RX</td>
<td align="left">f,1</td>
<td align="left">E</td>
<td align="left">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td align="left">store</td>
<td align="left">RX</td>
<td align="left">f,2</td>
<td align="left">E</td>
<td align="left">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td align="left">jump</td>
<td align="left">RX</td>
<td align="left">f,3</td>
<td align="left">E</td>
<td align="left">pc := ea</td>
</tr>
<tr class="odd">
<td align="left">jumpf</td>
<td align="left">RX</td>
<td align="left">f,4</td>
<td align="left">E</td>
<td align="left">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td align="left">jumpt</td>
<td align="left">RX</td>
<td align="left">f,5</td>
<td align="left">E</td>
<td align="left">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td align="left">jal</td>
<td align="left">RX</td>
<td align="left">f,6</td>
<td align="left">E</td>
<td align="left">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td align="left">inton</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">ie := 1</td>
</tr>
<tr class="odd">
<td align="left">intoff</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">ie := 0</td>
</tr>
<tr class="even">
<td align="left">sysoff</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">sys := 0</td>
</tr>
<tr class="odd">
<td align="left">getrem</td>
<td align="left">EXP</td>
<td align="left">e,00</td>
<td align="left"></td>
<td align="left">r[d] := rem</td>
</tr>
<tr class="even">
<td align="left">putrem</td>
<td align="left">EXP</td>
<td align="left">e,01</td>
<td align="left"></td>
<td align="left">rem := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getcsa</td>
<td align="left">EXP</td>
<td align="left">e,02</td>
<td align="left">P</td>
<td align="left">r[d] := csa</td>
</tr>
<tr class="even">
<td align="left">putcsa</td>
<td align="left">EXP</td>
<td align="left">e,03</td>
<td align="left">P</td>
<td align="left">csa := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getcsl</td>
<td align="left">EXP</td>
<td align="left">e,04</td>
<td align="left">P</td>
<td align="left">r[d] := csl</td>
</tr>
<tr class="even">
<td align="left">putcsl</td>
<td align="left">EXP</td>
<td align="left">e,05</td>
<td align="left">P</td>
<td align="left">csl := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getdsa</td>
<td align="left">EXP</td>
<td align="left">e,06</td>
<td align="left">P</td>
<td align="left">r[d] := dsa</td>
</tr>
<tr class="even">
<td align="left">putdsa</td>
<td align="left">EXP</td>
<td align="left">e,07</td>
<td align="left">P</td>
<td align="left">dsa := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getdsl</td>
<td align="left">EXP</td>
<td align="left">e,08</td>
<td align="left">P</td>
<td align="left">r[d] := dsl</td>
</tr>
<tr class="even">
<td align="left">putdsl</td>
<td align="left">EXP</td>
<td align="left">e,09</td>
<td align="left">P</td>
<td align="left">dsl := r[d]</td>
</tr>
<tr class="odd">
<td align="left">addl</td>
<td align="left">EXP</td>
<td align="left">e,0a</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] + r[b] + lsb rem</td>
</tr>
<tr class="even">
<td align="left">subl</td>
<td align="left">EXP</td>
<td align="left">e,0b</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] - r[b] + slb rem</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="assembly-language"><a href="#assembly-language">Assembly Language</a></h1>
<p>An assembly language provides a reasonably readable notation for writing machine language programs. An instruction in machine language is just one or more words (often written in hexadecimal notation), while the corresponding instruction in assembly language uses mnemonic names so the programmer doesn't have to memorise all the operation codes, addresses of variables, and so on. However, the assembly language still gives the programmer complete control over a program, down to the last bit.</p>
<p>Computer hardware executes machine language, which is hard for humans to read because it consists entirely of numbers. Assembly language is a way of expressing a machine language program in a readable way. It uses names for instructions and variables, as well as other notations to make the code easier to understand.</p>
<h2 id="notation"><a href="#notation">Notation</a></h2>
<p>Constants can be written in decimal, hexadecimal, or binary.</p>
<ul>
<li><p>Decimal constants consist of a sequence of digits, with an optional leading - sign. Examples: 42 55039 -1</p></li>
<li><p>Hexadecimal constants are written with a dollar sign $ followed by four hex digits (0 1 2 3 4 5 6 7 8 9 a b c d e f). Examples: <span class="math">0249</span>c78a</p></li>
<li><p>Binary constants are written with a hash sign # followed by any number of 0 or 1 characters. You can write fewer than 16 bits; they will be padded on the left with zeros. Examples: #1101 #000100000001101</p></li>
</ul>
<h2 id="assembly-instruction-fields"><a href="#assembly-instruction-fields">Assembly instruction fields</a></h2>
<p>An assembly language statement consists of three fields. A field is a string of non-space characters, and fields must be separated by spaces. The fields are:</p>
<ul>
<li><p>Label. This field is optional: if there is a label, it must begin in the first character of a line. If the first character is a space, then that line has no label. A label is similar to a variable name in a programming language. It must begin with a letter, and may contain letters, digits, and underscore characters.</p></li>
<li><p>Operation. This is the first field that appears after white space in the statement. The operation is the name of an instruction.</p></li>
<li><p>Operands. This field specifies the registers and memory addresses used by an instruction.</p></li>
<li><p>Comment. Everything on a line after a semicolon character is a comment, and is ignored by the assembler.</p></li>
</ul>
<h2 id="expressions"><a href="#expressions">Expressions</a></h2>
<p>An expression denotes a 16-bit word. Usually they are used to specify a word of machine language, either an address or a data constant.</p>
<p>Syntax of expressions</p>
<h2 id="assembly-language-statements"><a href="#assembly-language-statements">Assembly language statements</a></h2>
<p>name module name import export name</p>
<h2 id="object-language-statements"><a href="#object-language-statements">Object language statements</a></h2>
<p>hex4 means a 4-digit hexadecimal constant, such as 3b9f.</p>
<p>name means an identifier, beginning with a letter and comprising letters, digits, _</p>
<p>org hex4 set location counter data hex4 ... hex4 load words, incrementing loc counter relocate hex4 add relocation to word at address external name insert value of external name</p>
<h2 id="assembly-listing"><a href="#assembly-listing">Assembly listing</a></h2>
<p>The first section of the assembly listing shows each line of the source program. The line number appears first, followed by the memory address that the instruction on this line will be placed in. The address is given as a 4 digit hexadecimal number, and it is binary (not two's complement). Next comes the machine language code generated by the line of source code. If the line contains a two-word instruction, there will be two 4-digit hexadecimal values; for a one-word instruction there will be one hex number, and if the line doesn't produce any code these fields will be blank. After the code, the original source statement appears.</p>
<p>The second section of the assembly listing is the <em>Symbol Table</em>. This shows each identifier (or &quot;symbol&quot;) that appears in the program, the address allocated for the symbol, the source code line where it was defined, and the source code lines where it was used.</p>
<h1 id="linker"><a href="#linker">Linker</a></h1>
<p>The linker is not implemented in this version of the application.</p>
<h1 id="programming-the-sigma16-architecture"><a href="#programming-the-sigma16-architecture">Programming the Sigma16 architecture</a></h1>
<p>Coming soon.</p>
<h1 id="using-the-graphical-user-interface"><a href="#using-the-graphical-user-interface">Using the graphical user interface</a></h1>
<p>Coming soon</p>
<h1 id="about-the-software"><a href="#about-the-software">About the software</a></h1>
<p>Sigma16 is built using the Haskell programming language and the Hydra hardware description language. The documentation is written in markdown and prepared for a web browser using pandoc.</p>
<ul>
<li><a href="file:README.html">README</a></li>
<li><a href="file:LICENSE.html">LICENSE</a></li>
<li><a href="file:LICENSE_GPL3.html">Full text of GPL3 license</a></li>
</ul>
<h2 id="changes-underway"><a href="#changes-underway">Changes underway</a></h2>
<p>Support relocatable code</p>
<ul>
<li>Change jump, jumpt, jumpf, jal to use pc-relative addressing</li>
<li>Introduce a jalext that uses indexed absolute address, for external</li>
</ul>
<p>User flags register</p>
<ul>
<li>Carry output</li>
<li>Overflow</li>
<li>Carry input</li>
</ul>
<p>System flags register * System status * Interrupts enabled</p>
<p>Arithmetic Add/subtract with carry</p>
<p>Input/Output dma channels Ready Ack</p>
<h1 id="installation"><a href="#installation">Installation</a></h1>
<h3 id="hiding-the-console-on-windows"><a href="#hiding-the-console-on-windows">Hiding the console on Windows</a></h3>
<p>See http://projects.haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/</p>
<p>The way to hide the console window it is to pass a special linker option when compiling your program:</p>
<p>ghc --make Foo.hs -optl-mwindows</p>
<h2 id="using-a-pre-compiled-directory"><a href="#using-a-pre-compiled-directory">Using a pre-compiled directory</a></h2>
<p>There may be a pre-compiled version for your platform. If so, this would be a directory (folder) containing all the files needed.</p>
<h3 id="compiling-from-source"><a href="#compiling-from-source">Compiling from source</a></h3>
<h3 id="prerequisite-software"><a href="#prerequisite-software">Prerequisite software</a></h3>
<p>To compile Hydra, you need the Glasgow Haskell Compiler (ghc). In addition, some but not all of the features require ghc to be installed on the computer on which you're running Hydra. Thus it is possible to compile Hydra on one computer and then to copy the binaries to another.</p>
<p>To check whether you have an up-to-date ghc installed, enter</p>
<pre><code> ghc --version</code></pre>
<p>See the file Hydra.cabal for specific dependencies: the particular version of ghc that is required, and the auxiliary packages that need to be installed. These include:</p>
</body>
</html>
